#!/usr/bin/perl -w
###########################################################################
# sparse 1.0d - a script to scan input from /var/log/messages, a user's 
#         mail file, and the 'ckfile(PID)' file produced by 'safe' and
#         analyze what should have been caught by the scanner, and what
#	  was caught.
###########################################################################
#     Highly dependent on changes in the smapd scanner, since we often key 
#     on strings inserted by the scanner. Also dependent on the 'safe' 
#     script, but we have control over that.
###########################################################################

use strict;

use Getopt::Long;
use vars qw( $Level $verbose $Verbose $Repair $Progress $Help );
use MIME::Base64;
use Convert::UU qw(uudecode);
use Digest::MD5 qw(md5_hex);

use oe;
use safe;

( my $Cmd = $0 ) =~ s@^.*/@@;
my $Usage = <<USAGE ;

Usage:
$Cmd message_file mail_file senders_file

USAGE

Getopt::Long::Configure( "no_ignore_case" );
die $Usage unless GetOptions (
	"help|?"	=> \$Help,
);
die $Usage if $Help;

# We have to have all of the input files, or we quit
die $Usage unless @ARGV == 3;

my ( $message_file, $mail_file, $senders_file ) = @ARGV;
die "Can't open message_file ($message_file)\n" unless -r $message_file;
die "Can't open mail_file ($mail_file)\n" unless -r $mail_file;
die "Can't open senders_file ($senders_file)\n" unless -r $senders_file;

my %sender;		# Keyed on the smap 'xma999999' number; values are 
			# the local names of the senders

my %ids;		# Keyed on the Message-IDs; values are the smapd PIDs

my %smapid;		# Keyed on the smapd PID; values are the 'sma999999'
			# numbers 

my %sendmailpid;	# Keyed on the smapd PID; value is the sendmail
			# PID reported by smapd on the handoff. Not currently
			# used.

my %message;		# Keyed on the Message-ID; value is the syslog
			# message reported by smapd. Not currently used.
			# At one time these were put in the output file,
			# but they cluttered things up a bit, and didn't
			# prove much since they apply only to the first
			# virus found anyway. We could dump them all to
			# a second output file if it would be useful.

my %senders;		# Keyed on the local name of the sender; values are
			# the attachments to the message

my %count;		# Keyed on the local name of the sender; value is
			# the number of times the sender was reported 
			# processed by smap. Should be '1' for all of the
			# 'constructed' senders.

my %count2;		# Keyed on the smap ID; counts number of times this
			# message delivered by smapd. Should always be '1'
			# at the end of the run.
			
my $Error;		# Set if any message not handled properly
my $Minor;		# Set if minor errors occurred

# The senders file has a constructed user name, followed by a list of
# attachments. Format of the entries is:
# oeM0BM12345@domainname: attach1 attach2 attach3 ...
# 0123456 7~
# 0-1 : Mailer (Outlook Express)
# 2   : M - MIME encoding; U - UUencoding
# 3   : "Text" level
# 4-5 : Attachment type (see safe.pm for expansions; this key is first
#       two letters with "AL" for ALL attachments)
# 6-10: PID
open IN, "<$senders_file" or die "Can't open senders file; ";
print "Reading $senders_file...\n";
while (<IN>) {
	my ($key, undef) = split /\@/, $_;
	$senders{$key}++;
}
close IN;

# Here it starts to get ugly, as we pull all kinds of information out of
# the files, but we should find a use for most of this stuff someplace
# (either now or in a later version...)

my %xma;
open IN, "$message_file" or die "Couldn't open input file; ";
print "Reading $message_file...\n";
while (<IN>) {
	if ( /smap\[.*from=<(.*?)@.*to=.*file=.*xma([\w\.]{6,9})$/ ) {
		# skip messages that aren't in our senders list
		next unless grep { /$1/ } keys %senders;
		$xma{$2}=$1;
		$count{$1}++;
	}
	if ( /smapd?\[(\d+)\]:.*Message-I[dD]: <(.*)>/ ) {
		$ids{$2} = $1;
	} elsif ( /smapd?\[(\d+)\]:.*delivered file=.*[xs]ma([\w\.]{6,9}) pid=(\d+).*$/ ) {
		$smapid{$1} = $2;
		$count2{$xma{$2}}++ if defined $xma{$2};
#		$sendmailpid{$1} = $3; # Not now used, but may be useful later. 
	} elsif ( /smap\[(\d+)\]: (.*)/ ) {
		$message{$1} .= "$2";
	}
}

open IN, "<$mail_file" or die "Couldn't open mail file: ";
print "Reading $mail_file...\n";
my $messages;
{ local $/; $messages = <IN> }
my @messages = split /\n\n(?=From )/, $messages;

# Now that we know what was sent, we figure out what was received
#
# We're going to write our output to a file in the current directory.
# The filename will be the same for each run to avoid accumulation of
# debris when the user never bothers to remove the old file.
open OUT, ">cksafe.out" or die "Couldn't open output file.\n";
print "Putting it all together (this could take a while)...\n";

my @delivered;
foreach ( @messages ) {
	my $sender = substr $_, 5, index( $_, "\@" ) - 5;
	# Skip it unless its something generated by 'safe'
	next unless defined $senders{$sender};
	push @delivered, $sender;
	/.*message-id: <(.*)>.*/i and $message{$1} = $_;
	parse( $_ );
}
print "\n";

print "All delivered mail apparently arrived intact.\n" unless $Error;

# This last couple of chunks should go largely unused. But it does allow
# us to confirm that all messages were processed, and that they were
# received only once.

foreach my $s ( sort keys %senders ) {
# The next two clauses do not work with the new streaming csmap. I have
# just commented them out since they are somewhat redundant now (they
# were originally put in to track a specific problem). If a need for
# them arises, they will need to be rewritten and these lines may serve
# as an idea of what needs to be done.
#	unless ( grep { /$s/ } keys %count ) {
#		print "Mail from $s was not processed.\n";
#		print OUT "Mail from $s was not processed.\n";
#		next;
#	}
#	unless ( grep { /$s/ } keys %count2 ) {
#		print "Mail from $s was not delivered to sendmail.\n";
#		print OUT "Mail from $s was not delivered to sendmail.\n";
#		next;
#	}
	unless ( grep { /$s/ } @delivered ) {
		print "Mail from $s was not received by the addressee.\n";
		print OUT "Mail from $s was not received by the addressee.\n";
	}
}

foreach ( sort keys %count ) {
	if ( $count{$_} > 1 ) {
		print "$_: processed $count{$_} times by smap.\n";
		print OUT "$_: processed $count{$_} times by smap.\n";
	}
}

close OUT;
exit;
#
# End of main script
#

sub parse($) {
	my $message = shift;
	if ( "U" eq substr $message, 7, 1) {
		uuchk( $message );
	} else {
		mimechk( $message );
	}
}

sub uuchk($) {
	my $message = shift;
	my $sender = substr $message, 5, index( $message, "\@" ) - 5;
	while ( $message =~ /(begin \d{3} .*?^end$)/smg ) {
		my ( $content, $file, $mode ) = uudecode $1;
		unless ( $MD5{$file} eq md5_hex($content) ) {
			print qq("$file" from "$sender" seems to have a problem.\n);
			$Error++;
		}
	}
}

sub mimechk($) {
	my $message = shift;
	my $sender = substr $message, 5, index( $message, "\@" ) - 5;
	my $Boundary = $oe_win{BOUNDARY};

	# This first split is bogus, since it include many things that
	# aren't attachments, but it's a start.
	my @sections = split /$Boundary/, $message;

	# This cuts it down to the encoded attachments.
	my @attach = grep { /content-transfer-encoding: base64/i } @sections;

	foreach ( @attach ) {
		# This may not work for mailers other than Outlook Express
		my ($hdr, $content) = split /\n\n/, $_;

		# But this should...
		(my $fname = $hdr) =~ s/.*filename="(.*)"/$1/s;
		my $file_content = decode_base64($content);
		unless ( $MD5{ (split / /, $fname)[0] } eq md5_hex($file_content) ) {
			print qq("$fname" from "$sender" seems to have a problem.\n);
			$Error++;
		}
	}
}

__END__

=head1 NAME

B<checksafe> - Analyze the results of a B<safe> run

=head1 SYNOPSIS

B<checksafe> B<messages_file mail_file senders_file>

B<parse> B<messages_file mail_file senders_file>

=head1 DESCRIPTION

B<checksafe> takes as input a F</var/log/messages> file (or extract), a user mailbox (e.g., F</var/spool/mail/user>), and a senders file consisting of one or more output files from B<safe>, and analyses the results.

=head2 Output

All errors are written to STD_OUT and to a file in the current directory named F<cksafe.out> during the run.

=head1 OPTIONS

=over 4

=item B<--help|-he|-?> help

Prints out a brief help message.

=head1 ENVIRONMENT

The modules (I<oe.pm> and I<safe.pm> used by B<checksafe> must be placed in a directory where they can be read; probably the best place is a I<lib> (or other name) directory in your home directory which you include in your B<PERL5LIB> environment variable.

Besides its own modules B<checksafe> needs several other modules to run:

=over 4

=item B<MIME::Base64>

=item B<Convert::UU>

=item B<Digest::MD5>

=back

All of these modules are available from CPAN.

=head1 FILES

F<safe.pm>
F<oe.pm>

=head1 SEE ALSO

B<safe>
B<mailem>
B<parse>

=head1 AUTHOR

Larry Prall <lprall@nai.com>
